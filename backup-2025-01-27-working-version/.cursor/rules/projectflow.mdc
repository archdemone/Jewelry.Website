---
alwaysApply: true
---

4) CI / automation (minimum viable)

On PR / main:

npm ci

npm run type-check:strict + npm run lint

npm run build

Smoke: start on random port, wait-on /:200, curl /api/healthz expect 200

Artifacts: upload .next and Lighthouse JSON if you run perf in CI.

Secrets: CI uses repo/environment secrets; never echo secret values.

5) Frontend stability & perf guardrails

LCP hero:

Use next/image with priority on the first visible hero image only.

Real dimensions (avoid CLS), serve WebP/AVIF, target ≤ 200 KB.

Avoid JS-driven carousels for LCP element; use CSS scroll-snap or render first slide statically.

TBT / main-thread:

Dynamic import heavy UI (next/dynamic({ ssr:false })) below the fold.

Defer/idle-load third-party scripts; remove unused.

Caching / headers:

Static assets: long max-age + immutable.

HTML/JSON: short max-age, ETag enabled.

SW pitfalls: never cache HTML as “cache-first”; prefer network-first with fallback.

Budgets (don’t break them):

LCP < 2.5s, TBT < 300 ms, CLS < 0.1, First Load JS (route) < 2 MB.

6) Backend & data (Prisma)

Local: sandbox DB separate from baseline (e.g. file:./sandbox.db). Never point sandbox to prod.

Migrations:

Local dev: prisma migrate dev (sandbox only).

Promotion: create migration in sandbox, apply patch to main, run prisma migrate deploy in CI/live.

Health:

/api/healthz must return 200 quickly (DB optional).

Log structured JSON (pino) with level info in prod, debug in dev.